package genlab.algog.algos.exec;

import genlab.algog.algos.instance.GeneticExplorationAlgoContainerInstance;
import genlab.algog.internal.AGene;
import genlab.algog.internal.AGenome;
import genlab.algog.internal.ANumericGene;
import genlab.algog.internal.AnIndividual;
import genlab.core.exec.IExecution;

import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public abstract class BasicGeneticExplorationAlgoExec extends
		AbstractGeneticExplorationAlgoExec {

	public BasicGeneticExplorationAlgoExec(IExecution exec,
			GeneticExplorationAlgoContainerInstance algoInst) {
		super(exec, algoInst);
	}
	



	/**
	 * Step "construct population" of the genetic algo. Called only for the very first one.
	 * @return
	 */
	protected Map<AGenome,Object[][]> generateInitialPopulation() {
	

		// associates each geneome to its corresponding population (for one generation)
		Map<AGenome,Object[][]> genome2population = new HashMap<AGenome, Object[][]>();

		// generate the novel population for each specy
		// for each specy
		messages.debugUser("generation of the population for generation "+iterationsMade, getClass());
		for (AGenome genome : genome2algoInstance.keySet()) {
	
			messages.debugUser("generation of the sub population based on genome: "+genome, getClass());

			
			Object[][] population = generateInitialPopulation(genome, paramPopulationSize/genome2algoInstance.size());
			
			genome2population.put(genome, population);

			
		}
				
		return genome2population;
		
	}
	
	
<<<<<<< HEAD
=======
	/**
	 * Selects a part of the existing population based on fitness.
	 * @return
	 */
	protected abstract INextGeneration selectIndividuals(Map<AnIndividual,Double[]> indiv2fitness);
	

	@Override
	protected Map<AGenome,Object[][]> prepareNextGeneration() {
		
		int previousGenerationId = iterationsMade;
		
		// reuses the previous population
		final Map<AnIndividual,Double[]> indiv2fitness =  getIndivAndFitnessForLastGeneration();
		messages.infoUser("retrieved "+indiv2fitness.size()+" individuals from the previous generation "+previousGenerationId, getClass());
		
		// SELECT 
		
		// TODO elitism !
		
		final INextGeneration selectedIndividuals  = selectIndividuals(indiv2fitness);
		final Map<AGenome,Set<AnIndividual>> selectedGenome2Population = selectedIndividuals.getAllIndividuals();
		int totalIndividualsSelected = selectedIndividuals.getTotalOfIndividualsAllGenomes();
		messages.infoUser("selected for "+selectedGenome2Population.size()+" genome(s) a total of "+totalIndividualsSelected+" individuals", getClass());
		
		// TODO if the population is not big enough, recreate some novel individuals
		if (totalIndividualsSelected < paramPopulationSize) {
			messages.warnUser("not enough individuals selected ! Probably many individuals were not evaluated with success. We will create novel individuals to repopulate the population", getClass());

			for (AGenome genome : selectedGenome2Population.keySet()) {
				
				Set<AnIndividual> individuals = selectedGenome2Population.get(genome);
				
				int targetSizeForGenome = paramPopulationSize/genome2algoInstance.size(); // TODO should be what ?
				int diff = targetSizeForGenome - individuals.size(); 
				if (diff > 0) {
					
					messages.infoUser("adding "+diff +" new individuals in the population for genome "+genome.name, getClass());
					Object[][] population = generateInitialPopulation(genome, diff);
					for (Object[] indiv : population) {
						individuals.add(new AnIndividual(genome, indiv));
					}
				}
			}
			
		}
		
		// CROSS
		// TODO manage multi specy !
		
		Map<AGenome,Object[][]> novelGenome2Population = new HashMap<AGenome, Object[][]>();

		// stats on the count of mutation (to be returned to the user)
		Map<AGene<?>,Integer> statsGene2countMutations = new HashMap<AGene<?>, Integer>();
		
		for (AGenome genome: selectedGenome2Population.keySet()) {
			
			Set<AnIndividual> indivs = selectedGenome2Population.get(genome);
			
			// generate the next generation
			Object[][] novelPopulation = generateNextGenerationWithCrossover(
					genome, 
					indivs, 
					paramPopulationSize
					);
			
			// mutate in this novel generation
			mutatePopulation(genome, novelPopulation, statsGene2countMutations);
			
			// store this novel generation
			novelGenome2Population.put(genome, novelPopulation);
			
		}
		
		{
			StringBuffer sb = new StringBuffer();
			sb.append("during the generation of the population ").append(iterationsMade);
			sb.append(" there were these mutations per gene: ");
			for (Map.Entry<AGene<?>,Integer> gene2count : statsGene2countMutations.entrySet()) {
				sb.append(gene2count.getKey().name);
				sb.append(":");
				sb.append(gene2count.getValue());
				sb.append("; ");
			}
			messages.infoUser(sb.toString(), getClass());
		}
		
		exportContinuousOutput();
		
		return novelGenome2Population;
		
	}
>>>>>>> 42920ed9722b75f2dcffb38eb09a55b4927000bd
	

	@Override
	protected boolean hasConverged() {
		// in the 
		return false;
	}

}
